<!--#set var="TITLE" value="Documentation :: YASS" --><!--#set var="LANG" value="/ru" --><!--#include virtual="/includes/top.shtml" -->
<div class="documentation">
<h2>Документация</h2>
<p>YASS &mdash; это небольшая JavaScript-библиотека для выбора элементов из DOM-дерева по CSS-селекторам. Она поддерживает некоторые наиболее распространенные комбинации CSS-селекторов, которые <a href="http://www.w3.org/TR/2005/WD-css3-selectors-20051215/" rel="nofollow">приведены в CSS3-спецификации</a>.</p>

<h3>Параметры функции <code>_</code> или <code>yass</code></h3>

<p>Основная функция для выбора элементов получает на вход 3 параметра: сам CSS-селектор, корневой элемент для выборки (по умолчанию берется <code>document</code>) и параметр <code>noCache</code> для сброса кэша по заданному селектору (кэщ будет автоматически сброшен для современных браузеров, но для IE его нужно сбрасывать вручную после изменений в HTML).</p>

<p>Более подробно <a href="/ru/tutorials/">примеры использования</a> приведены в соответствующей секции.</p>

<h3>Поддерживаемые селекторы:</h3>

<ul>
<li>для выбора класса (например, <code>.example</code>),</li>
<li>для выбора узлов по имени тега: <code>span</code> или <code>div</code>,</li>
<li>наследование (например, <code>div p a</code>),</li>
<li>выбор дочерних элементов через <code>&gt;</code>,</li>
<li>выбор дочерних узлов первого уровня через <code>~</code>,</li>
<li>выбор первого дочернего узла с помощью <code>+</code>,</li>
<li>выбор элементов по идентификатору <code>#id</code>,</li>
<li>универсальный селектор &mdash; <code>*</code>,</li>
<li>запросы к атрибутам:<ul>
<li><code>[type=checkbox]</code> атрибуты с точным значением (<code>class</code> отработает по совпадению подстроки),</li>
<li><code>[title]</code> &mdash; существование атрибута у элемента,</li>
<li><code>[rel~=nofollow]</code> &mdash; наличие в атрибуте заданной строке в качестве значения, разделенного пробелами,</li>
<li><code>[class^=block]</code> &mdash; значение атрибута, начинающееся с заданного значения,</li>
<li><code>[class$=hidden]</code> &mdash; или заканчивающегося ею,</li>
<li><code>[alt*=image]</code> &mdash; соответствие подстроки значения атрибута заданной,</li>
<li><code>[alt!=image]</code> &mdash; отсутствие в атрибуте заданной строке в качестве значения, разделенного пробелами,</li>
</ul></li>
<li>позиции элементов относительно родителей: <code>:first-child</code>, <code>:last-child</code>,</li>
<li>пустые элементы через селектор <code>:empty</code>,</li>
<li>корневой элемент (<code>HTML</code>) через <code>:root</code>,</li>
<li>выбранные элменты формы через псевдо-селектор <code>:checked</code>,</li>
<li>позиция элемента в родительском элементе &mdash; <code>:nth-child(3)</code>,</li>
<li>выбор элементов по заданной позиции через <code>:nth-child(even)</code>, <code>:nth-child(odd)</code>, <code>:nth-child(2n+1)</code>,</li>
<li>псевдо-селетор языка <code>:lang</code>.</li>
</ul>

<p>Все допустимые комбинации этих селекторов будут работать через вызов функции _(), в том числе влючая наборы селекторов, разделенных запятой ",". Возвращаемое значение будет либо одним узлом DOM-дерева, либо набором таких узлов. Если ни один элемент не соответстует заданному селектору, то YASS вернет <code>null</code>.</p>

<h3>Неподдерживаемые селекторы:</h3>

<p>Некоторые селекторы пока еще не поддерживаются. Вполне возможно, что ситуация изменится с выходом новых версий YASS.</p>

<ul>
<li>отрицательный селектор <code>:not(...)</code>,</li>
<li>множественные селекторы <code>[class=class1][class=class2]</code>.</li>
</ul>

<h3>API для модулей</h3>

<p>YASS является весьма гибкой библиотекой для подключения совершенно произвольных внешних JS-файлов как модулей. Например, можно динамически полностью загрузить Prototype или jQuery со всеми плагинами сразу после загрузки ядра YASS. Для этого нужно написать следующий код:</p>

<p><code>&lt;script src="yass.js" type="text/javascript" class="yass-module-jquery"&gt;&lt;/script&gt;</code></p>

<p>В этом примере:</p>

<ol>
<li>YASS загрузится обычным образом.</li>
<li>Далее загрузится файл <code>yass.jquery.js</code>, который расположен там же где и исходный HTML-файл. И произойдет это по событию DOM ready.</li>
</ol>

<p>Также можно загрузить любой внешний файл как модуль YASS. Например:</p>

<p><code>&lt;script src="yass.js" type="text/javascript" class="yass-module-http://ajax.googleapis.com/ajax/libs/jquery/1.3/jquery.min.js"&gt;&lt;/script&gt;</code></p>

<p>В конце кода для каждого модуля можно:</p>

<ul>
<li><p>Вызвать какое-то действие по загрузке всего дерева зависимостей для данного модуля. Зависимости записываются в классе произвольного узла DOM-дерева, например:</p>
<p><code>&lt;div class="yass-module-base#jquery"&gt;&lt;/div&gt;</code></p>
<p>В этом случае модуль <code>jquery</code> зависит от модуля <code>base</code>, и окончательное событие <code>load</code> не будет вызвано, пока вся цепочка зависимостей не загрузится полностью.</p>
<p>Задать логику обработчика события загрузки модуля можно через <code>init</code>:</p>
<p><code>_.modules[modules_name]['init'] = function(){...}</code></p>
<p>Для модуля <code>base</code> искомый код будет выглядеть (в конце файла <code>yass.base.js</code>):</p>
<p><code>_.modules['base']['init'] = function(){...}</code></p></li>
<li><p>Динамически сформировать дерево зависимостей в процессе загрузке. Для этого в конце загружаемого модуля достаточно вызвать <code>_.init(module_dependency + '#' + module_name)</code>, где <code>module_dependency</code> &mdash; модуль, от которого зависит загруженный. Тогда событие <code>load</code> не будет вызвано, пока не загрузится этот новый модуль.</p></li>
<li><p>Вызвать любой обработчик сразу после загрузки самого JS-файла (в обход любых зависимостей). Для этого нужно записать в <code>title</code> искомого DOM-узла:</p>
<p><code>&lt;div id="jquery" class="yass-module-jquery" title="$('jquery').html('jQuery загружена через YASS')"&gt;&lt;/div&gt;</code></p>
<p>Сразу после загрузки и инициализации <code>yass.jquery.js</code> будет вызван код, заключенный в атрибуте <code>title</code>.</p></li>
<li><p>Тажке можно использовать выделенное пространство имен для хранения специфичных параметров или объектов. Это пространство расположено в <code>_.modules[module_name]</code>. Там уже находятся некоторые предопределенные переменные и объекты:</p>
<ul>
<li><code>_.modules[module_name].status</code> указывает на текущее состояние соответствующего модуля (0 &mdash; еще не загружен, 1 &mdash; в процессе загрузки, 2 &mdash; загружен, 3 &mdash; ожидает разрешения зависимостей, -1 &mdash; не может быть загружен).</li>
<li><code>_.modules[module_name].yass</code> &mdash; хэш модулей, которые зависят от данного.</li>
<li><code>_.modules[module_name].deps</code> &mdash; массив модулей, от которых зависит данный.</li>
<li><code>_.modules[module_name].notloaded</code> &mdash; число незагруженных зависимостей.</li>
<li><code>_.modules[module_name].deps.yass</code> &mdash; хэш модулей, от которых зависит данный.</li>
</ul>
<p>Крайне рекомендуется использовать данное пространство имен для всех специфических переменных, связанных с модулем, чтобы исбежать захламления глобальной области видимости.</p>
</li>
</ul>

<p>Дополнительные примеры использования данной логики можно подчерпнуть из <a href="http://webo.in/tests/yass-tree-load/">онлайн-демонстрации загрузки дерева модулей</a>.</p>
</div>
<!--#include virtual="/includes/bottom.shtml" -->